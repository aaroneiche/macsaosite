import { useState, useEffect, useContext } from "react";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  // arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  // verticalListSortingStrategy,
  // SortingStrategy
  
} from "@dnd-kit/sortable";

// import { BytesContext } from "../App";

import { CommandPalette } from "./CommandPalette";

import '../App.css';
import './Sortable.css';

import { SortableItem } from "./Sortable";
import { BytesContext } from "../App";

function ByteBuilder() {
  // const [bytes, setBytes] = useState(example);
  const {bytes, setBytes} = useContext(BytesContext);

  const [bytesToSend, setBytesToSend] = useState<string[]>([]);

  const [addressInput, setAddressInput] = useState("0010");
  const [baseAddress, setBaseAddress] = useState<number>(16);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );
 
  const clearBytes = ()=>{
    setBytes!([]);
  };

  const generateBytes = () => {
    const byteSet: string[] = [];
    
    bytes.forEach(b=>{
      byteSet.push(String(b.command));

      if(typeof b.args !== 'function' && b.args.length !== 0) {
        b.args.forEach(a=>{
          byteSet.push((a.val.length === 0)? "?" : a.val)
        }       
        )
      }else if(typeof b.args == 'function' && b.out && b.value) { 
        b.out(b.value).forEach((c: number) => byteSet.push(String(c)));
        byteSet.push("0"); //officially ends the string.
      }
    })

    setBytesToSend(byteSet);
  }


  const getAddressForByte = (byteIndex: number) => {
    let addr = baseAddress;
    let c = 0;
    while(c < byteIndex) {
      addr += 1;
      if(typeof bytes[c].args != "function"){
        addr += bytes[c].args.length;
      }
      c++;
    }

    return addr;
  }

  
  const copyBytesToClipboard = () => {
    navigator.clipboard.writeText(bytesToSend.join(" "));
  }

  useEffect(()=>{
    setBaseAddress(parseInt(addressInput,16));
  },[addressInput])


  useEffect(()=>{
    generateBytes();
  },[bytes])


  const sortableBytes = bytes.map((b,i) => {
    return (
    <SortableItem
      key={b.id}
      id={b.id}
      name={b.name}
      command={b.command}
      args={b.args}
      currentAddress={getAddressForByte(i)}
      bytes={bytes} //In case you want to mess with the object directly.
      setBytes={setBytes!}
    />
    );
  });
 
  const displayCommandBytes = bytesToSend.map((b) => `${b} `);

  return (
    <div id="byteBuilderBlock">
      <div className="modal-dialog outer-border" style={{ width: "30rem" }}>
        <div className="inner-border center">
          <div className="modal-contents">
            <label className="modal-text">Starting Address: </label>
            0x
            <input
              name="startingAddress"
              type="text"
              size={4}
              value={addressInput}
              onChange={(e) => {
                setAddressInput(e.target.value);
              }}
            />
            <div id="bytesOutput">
              <span>Generated Bytes</span>
              <div id="generatedBytes">{displayCommandBytes}</div>
              {/* <button </button> */}
            </div>
            <section
              className="field-row"
              style={{ justifyContent: "flex-end" }}
            >
              {/* <button className="btn">Cancel</button> */}
              
              <button className="btn" onClick={copyBytesToClipboard}  style={{ width: "135px" }}>
                Copy Bytes
              </button>
            </section>
          </div>
        </div>
      </div>

      {/*       <div id="upperBlock">
        <div id="startingAddress">
          <label>Starting Address: </label>
          0x
          <input
            name="startingAddress"
            type="text"
            size={4}
            value={addressInput}
            onChange={(e) => {
              setAddressInput(e.target.value);
            }}
          />
        </div>
        <div id="bytesOutput">
          <span>Generated Bytes</span>
          <div id="generatedBytes">{displayCommandBytes}</div>
          <button onClick={copyBytesToClipboard}>Copy Bytes</button>
        </div>
      </div> */}

      <div className="window">
        <div className="title-bar">
          <button aria-label="Close" className="close"></button>
          <h1 className="title">Byte Builder</h1>
          <button aria-label="Resize" className="resize"></button>
        </div>
        <div className="separator"></div>

        <div className="window-pane">
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={bytes} /* strategy={verticalListSortingStrategy} */
            >
              <div className="grid">{sortableBytes}</div>
            </SortableContext>
          </DndContext>
        </div>
      </div>

      <br />

      <CommandPalette bytes={bytes} setBytes={setBytes!} />
      <button onClick={clearBytes}>Clear Bytes</button>
    </div>
  );

  function handleDragEnd(event:DragEndEvent) {
    const { active, over } = event;

    if(active.id !== over?.id) {
      console.log(over);
      const newBytesOrder = [...bytes];

      const destination = newBytesOrder.findIndex((k) => k.id == over?.id);

      const movedByte = newBytesOrder.splice(newBytesOrder.findIndex(k=>k.id==active.id),1);
      newBytesOrder.splice(destination,0, movedByte[0]);
      
      setBytes!(newBytesOrder);

    }
  }
}
export default ByteBuilder;