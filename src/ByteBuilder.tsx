import { useState, useEffect } from "react";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from "@dnd-kit/core";
import {
  // arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  // verticalListSortingStrategy,
  // SortingStrategy
  
} from "@dnd-kit/sortable";

import { CommandPalette } from "./CommandPalette";

import './App.css';
import './Sortable.css';

import {example} from './commandBytes';

import { SortableItem } from "./Sortable";

function ByteBuilder() {
  const [bytes, setBytes] = useState(example);

  const [bytesToSend, setBytesToSend] = useState<string[]>([]);

  const [addressInput, setAddressInput] = useState("0010");
  const [baseAddress, setBaseAddress] = useState<number>(16);
  // const [addressCounter, setAddressCounter] = useState<number>(0);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );
 
  const clearBytes = ()=>{
    setBytes([]);
  };

  const generateBytes = () => {
    const byteSet: string[] = [];
    
    bytes.forEach(b=>{
      byteSet.push(String(b.command));

      if(typeof b.args !== 'function' && b.args.length !== 0) {
        b.args.forEach(a=>{
          byteSet.push((a.val.length === 0)? "?" : a.val)
        }       
        )
      }else if(typeof b.args == 'function' && b.out && b.value) { 
        b.out(b.value).forEach((c: number) => byteSet.push(String(c)));
        byteSet.push("0"); //officially ends the string.
      }
    })

    setBytesToSend(byteSet);
  }


  const getAddressForByte = (byteIndex: number) => {
    let addr = baseAddress;
    let c = 0;
    while(c < byteIndex) {
      addr += 1;
      if(typeof bytes[c].args != "function"){
        addr += bytes[c].args.length;
      }
      c++;
    }

    return addr;
  }

  
  const copyBytesToClipboard = () => {
    navigator.clipboard.writeText(bytesToSend.join(" "));
  }

  useEffect(()=>{
    setBaseAddress(parseInt(addressInput,16));
  },[addressInput])


  useEffect(()=>{
    generateBytes();
  },[bytes])


  const sortableBytes = bytes.map((b,i) => {
    return (
    <SortableItem
      key={b.id}
      id={b.id}
      name={b.name}
      command={b.command}
      args={b.args}
      currentAddress={getAddressForByte(i)}
      bytes={bytes} //In case you want to mess with the object directly.
      setBytes={setBytes}
    />
    );
  });
 
  const displayCommandBytes = bytesToSend.map((b) => `${b} `);

  return (
    <>
      <div id="upperBlock">
        <div id="startingAddress">
          <label>Starting Address: </label>
          0x
          <input
            name="startingAddress"
            type="text"
            size={4}
            value={addressInput}
            onChange={(e) => {
              setAddressInput(e.target.value);
            }}
          />
        </div>
        <div id="bytesOutput">
          <span>Generated Bytes</span>
          <div id="generatedBytes">{displayCommandBytes}</div>
          <button onClick={copyBytesToClipboard}>Copy Bytes</button>
        </div>
      </div>

      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
      >
        <SortableContext
          items={bytes} /* strategy={verticalListSortingStrategy} */
        >
          <div className="grid">{sortableBytes}</div>
        </SortableContext>
      </DndContext>
      <br />

      <CommandPalette bytes={bytes} setBytes={setBytes} />
      <button onClick={clearBytes}>Clear Bytes</button>
    </>
  );

  function handleDragEnd(event:DragEndEvent) {
    const { active, over } = event;

    if(active.id !== over?.id) {
      console.log(over);
      const newBytesOrder = [...bytes];

      const destination = newBytesOrder.findIndex((k) => k.id == over?.id);

      const movedByte = newBytesOrder.splice(newBytesOrder.findIndex(k=>k.id==active.id),1);
      newBytesOrder.splice(destination,0, movedByte[0]);
      
      setBytes(newBytesOrder);

    }
  }
}
export default ByteBuilder;